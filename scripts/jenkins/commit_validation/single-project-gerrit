#!/bin/bash
#
# Common script run by various Jenkins commit-validation builds.
#
# Checks out all the gerrit changes with change-ids matching
# $GERRIT_PATCHSET_REVISION in an appropriate branch for the current
# manifest from Gerrit server GERRIT_HOST:GERRIT_PORT, compiles and then
# runs unit tests for GERRIT_PROJECT (if applicable).
#
# Triggered on patchset creation in a project's repo.

if [ -z "$GERRIT_HOST" ]; then
    echo "Error: Required environment variable 'GERRIT_HOST' not set."
    exit 1
fi
if [ -z "$GERRIT_PORT" ]; then
    echo "Error: Required environment variable 'GERRIT_PORT' not set."
    exit 2
fi
if [ -z "$GERRIT_PROJECT" ]; then
    echo "Error: Required environment variable 'GERRIT_PROJECT' not set."
    exit 3
fi
if [ -z "$GERRIT_PATCHSET_REVISION" ]; then
    echo "Error: Required environment variable 'GERRIT_PATCHSET_REVISION' not set."
    exit 4
fi
if [ -z "$GERRIT_REFSPEC" ]; then
    echo "Error: Required environment variable 'GERRIT_REFSPEC' not set."
    exit 5
fi
# Optional env vars - how many jobs to run in parallel by default?
PARALLELISM="${PARALLELISM:-8}"
TEST_PARALLELISM="${TEST_PARALLELISM:-${PARALLELISM}}"

BASEDIR=$(cd $(dirname $BASH_SOURCE) && pwd)

source ~jenkins/.bash_profile

# CCACHE is good - use it if available.
export PATH=/usr/lib/ccache:$PATH

function echo_cmd {
    echo \# "$@"
    "$@"
}

# We define two error handler functions - a fatal one used for the
# manditory parts of the build (i.e. actually building Couchbase), and
# a deferred one which 'remembers' error(s) have occured but lets the
# rest of the script run.
# This is to maximise the number of tests we run (even if earlier
# tests fail), so developers see as many problems in a single run as
# possible, but ensures that the script still exits with the correct
# error code.
last_error=0
error_count=0

function fatal_error_handler() {
    last_error=$?
    echo "Fatal error - aborting"
    exit $last_error
}
function deferred_error_handler() {
    last_error=$?
    (( error_count++ ))
}

# Initially install the fatal handler.
trap fatal_error_handler ERR

cat <<EOF

============================================
===    environment                       ===
============================================
EOF
ulimit -a
echo ""
env | grep -iv password | grep -iv passwd | sort

cat <<EOF

============================================
===    clean                             ===
============================================
EOF
echo_cmd make clean-xfd-hard
echo_cmd rm -fr install

# Zero ccache stats, so we can measure how much space this build is
# consuming.
echo_cmd ccache -z

# Wipe out any core files left from a previous run.
echo_cmd rm -f /tmp/core.*

cat <<EOF

============================================
===       update all projects with       ===
===          the same Change-Id          ===
============================================
EOF
${BASEDIR}/checkout_dependencies.py $GERRIT_PATCHSET_REVISION $GERRIT_PROJECT $GERRIT_REFSPEC

cat <<EOF

============================================
===               Build                  ===
============================================
EOF
if [ -n "$ENABLE_CODE_COVERAGE" ]; then
   CMAKE_ARGS="${CMAKE_ARGS} -DCB_CODE_COVERAGE=ON"
fi
if [ -n "$ENABLE_THREADSANITIZER" ]; then
   CMAKE_ARGS="${CMAKE_ARGS} -DCB_THREADSANITIZER=ON"
fi
echo_cmd make -j${PARALLELISM} EXTRA_CMAKE_OPTIONS="${CMAKE_ARGS}"

echo_cmd ccache -s

# Manditory steps complete, install the deferred error handler.
trap deferred_error_handler ERR

if [ -n "$GOPROJECT" ]
then
    pushd ${repo_path}
    eval "${ENV_VARS} go build"
    eval "go vet"
    eval "${ENV_VARS} go test -v"
    popd
elif [ -f build/${GERRIT_PROJECT}/Makefile ]
then
    cat <<EOF

============================================
===          Run unit tests              ===
============================================
EOF
    pushd build/${GERRIT_PROJECT} 2>&1 > /dev/null

    if [ -n "$ENABLE_CODE_COVERAGE" ]; then
        # Reset code coverage counters (note optional hence the || true).
        echo_cmd make ${GERRIT_PROJECT}-coverage-zero-counters || true
    fi

    # -j${TEST_PARALLELISM} : Run tests in parallel.
    # -T Test   : Generate XML output file of test results.
    echo_cmd make test ARGS="-j${TEST_PARALLELISM} --output-on-failure --no-compress-output -T Test"

    # Generate code coverage report in XML format for Jenkins plugin.
    if [ -n "$ENABLE_CODE_COVERAGE" ]; then
        echo_cmd make ${GERRIT_PROJECT}-coverage-report-xml || true
    fi

    if [ -n "$RUN_TESTS_UNDER_VALGRIND" ]; then
        # Clear out any previous runs' output files
        oldfiles=`find . -name "memcheck.*.xml"`
        if [ -n "${oldfiles}" ]; then
            echo_cmd rm -f ${oldfiles}
        fi
        echo_cmd make test ARGS="-j${TEST_PARALLELISM} --output-on-failure --no-compress-output -D ExperimentalMemCheck --exclude-regex ${VALGRIND_TESTS_EXCLUDE}"
        # As part our test execution we run system commands which
        # unfortunately have leaks themselves
        # (e.g. /bin/sh). Therefore remove any results from such
        # programs Jenkins parses the results so we don't include
        # them.
        newfiles=`find . -name "memcheck.*.xml"`
        echo_cmd ${BASEDIR}/remove_irrelevant_memcheck_results.py ${newfiles}
    fi

    popd 2>&1 > /dev/null
else
    cat <<EOF

============================================
===  ${GERRIT_PROJECT} is not a Go project. It also doesn't have a Makefile.
===  Skipping Unit tests.
============================================
EOF
fi

# Check for core files - if present then archive them and the
# executable they are from (for post-mortem) and fail the build.
core_files=$(find /tmp/ -maxdepth 1 -name 'core.*' -print)
if [ -n "$core_files" ]; then
    cat <<EOF

*******************************************************
***  ERROR: Core file(s) found at the end of the build:
*******************************************************
EOF
    echo $core_files
    echo ""
    echo "Archiving core files and executables to workspace:"
    archive_dir=archived_core_dumps
    abs_archive_dir=$(pwd)/${archive_dir}
    mkdir -p $archive_dir
    # Wipe out any previous files in the archive.
    rm -fr $archive_dir/*

    IFS=$'\n'
    for core in $core_files; do
        cp --archive $core $archive_dir/

        if ! (hash gdb 2>/dev/null); then
            echo "Warning: gdb not found in PATH. Unable to determine which executable generated core file."
            continue
        fi

        # Determine the executable the core is from.
        prog_path=$(gdb --batch -ex "info auxv" --core $core 2>/dev/null \
            | grep 'AT_EXECFN' \
            | sed -e 's/.*"\([^"]\+\)"/\1/')

        # Determine the current working directory of the core. This is needed
        # as some of the shared libraries may have been loaded using relative paths.
        core_pwd=$(gdb --batch -ex "set print array on" \
                       -ex "p/s ((char***)&environ)[0][0]@100" \
                       $prog_path --core $core 2>/dev/null \
            | grep '"PWD=' \
            | sed -e 's/.*"PWD=\([^"]\+\)",/\1/')

        cp --archive --parents $prog_path $archive_dir/

        # Now determine all shared libraries which were loaded, and archive them,
        # along with any seperate debuginfo files.
        pushd $core_pwd >/dev/null
        for lib in $(gdb --batch -ex "info sharedlibrary" $prog_path --core $core 2>/dev/null \
            | grep -A999 'Shared Object Library' \
            | grep -v 'Shared Object Library' \
            | grep -v '(*): Shared library is missing debugging information.' \
            | cut -c 50- ); do

            cp --archive --parents --dereference $lib $abs_archive_dir/

            # Debuginfo files use the real name of the library, not
            # the symlink name.
            real_lib=$(readlink -f $lib)
            if [ -f "/usr/lib/debug/$real_lib" ]; then
                cp --archive --parents /usr/lib/debug/$real_lib $abs_archive_dir
            fi
        done

        echo -e "Core file '$core' - created by $(basename $prog_path)"
        echo -e "GDB command to debug (after extracting archive):"
        echo -e ""
        echo -e "    gdb ${prog_path#/} --core '$(basename $core)' -ex 'set debug-file-directory usr/lib/debug' -ex 'set sysroot .'"
        echo ""

        # Finally, give people a "sneak peak" of where the crash was
        # by dumping a backtrace.
        echo "Backtrace of crashing thread:"
        gdb --batch -ex "backtrace" $prog_path --core $core 2>/dev/null
        echo ""
        popd >/dev/null
    done

    # Compress the directory to save space on Jenkins
    tar cjf ${archive_dir}.tar.bz2 ${archive_dir}/

    echo "Archiving complete. Data for post-mortem saved to ${archive_dir}.tar.bz2"

    # Make a command exit with non-zero status, so overall script
    # status is failure (see deferred_error_handler)
    echo
    echo "*** Failing build due to presence of core files ***"
    echo ""
    false
fi

rm -f /tmp/core.*

exit $last_error
