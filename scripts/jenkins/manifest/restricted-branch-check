#!/usr/bin/env python

import os
import sys
import xml.etree.ElementTree as ET
import base64
import argparse
import re
import urllib

from jira import JIRA
from manifest_util import scan_manifests

"""
Intended to run as a Gerrit trigger. The following environment variables
must be set as Gerrit plugin would:
  GERRIT_PROJECT   GERRIT_BRANCH   GERRIT_CHANGE_COMMIT_MESSAGE
  GERRIT_CHANGE_URL   GERRIT_PATCHSET_NUMBER  GERRIT_EVENT_TYPE
"""
PROJECT=os.environ["GERRIT_PROJECT"]
BRANCH=os.environ["GERRIT_BRANCH"]
COMMIT_MSG=base64.b64decode(os.environ["GERRIT_CHANGE_COMMIT_MESSAGE"])

# Constants that may be set; useful for populating the error HTML
APPROVAL_TICKET = None
RELEASE_NAME = "Unknown"
REASON = None
MANIFEST = None

def check_branch_in_manifest(manifest_filename, meta):
  """
  Returns true if the PRODUCT/BRANCH are listed in the named manifest
  """
  print "Checking manifest {}".format(manifest_filename)
  manifest_et = ET.parse(os.path.join("./manifest", manifest_filename))
  project_et = manifest_et.find("./project[@name='{}']".format(PROJECT))
  if project_et is None:
    print "project {} not found".format(PROJECT)
    return False

  # Compute the default branch for the manifest
  default_branch = "master"
  default_et = manifest_et.find("./default")
  if default_et is not None:
    default_branch = default_et.get("branch", "master")

  # Pull out the branch for the given project
  project_branch = project_et.get("revision", default_branch)
  if project_branch != BRANCH:
    print "project {} on branch {}, not {}".format(PROJECT, project_branch, BRANCH)
    return False

  return True

def get_approved_tickets():
  """
  Given a Jira ticket ID, return all linked ticket IDs
  """
  global APPROVAL_TICKET
  assert APPROVAL_TICKET is not None
  with open("{}/.ssh/jira.pem".format(os.environ["HOME"]), "r") as key_cert_file:
    key_cert_data = key_cert_file.read()
  oauth_dict = {
    "access_token": "PrxvLiICry8gkXXPHqnorpRHjBCn3V0O",
    "access_token_secret": "kNX06aseOyJx3GnWmRH1w14UQ4o7puiV",
    "consumer_key": "ceej-ticket-key",
    "key_cert": key_cert_data
  }
  jira = JIRA({"server": "https://issues.couchbase.com"}, oauth=oauth_dict)
  links = [link.outwardIssue.key
    for link in jira.issue(APPROVAL_TICKET).fields.issuelinks
    if hasattr(link, "outwardIssue")]
  return links


def validate_change():
  """
  Checks the commit message for a ticket, and verifies it with the the
  approval ticket for the restricted manifest
  """
  global REASON, RELEASE_NAME, APPROVAL_TICKET, COMMIT_MSG
  # First ensure topic line mentions tickets, and pull them out.
  topic = COMMIT_MSG.split('\n', 1)[0]
  fix_tickets = re.findall("[A-Z]{2,5}-[0-9]{1,6}", topic)
  if len(fix_tickets) == 0:
    REASON = "the commit message does not name a ticket"
    return False

  # Now get list of approved tickets from master ticket, and ensure
  # all "fixed" tickets are approved.
  approved_tickets = get_approved_tickets()
  for tick in fix_tickets:
    if not tick in approved_tickets:
      REASON = "ticket {} is not approved for {} (see approval ticket {})".format(
        tick, RELEASE_NAME, APPROVAL_TICKET)
      return False
  return True

def output_report():
  """
  Outputs report explaining why change was restricted, and exits
  with non-0 return value
  """
  global REASON
  data = globals().copy()
  data.update(os.environ)
  # Specialized mailto: URL for new branch request
  tmpldir = os.path.dirname(os.path.abspath(__file__))
  with open(os.path.join(tmpldir, "mailto_url.tmpl")) as tmplfile:
    mailto_url = tmplfile.read().strip().format(**data)
    print mailto_url
    data["MAILTO_URL"] = urllib.quote(mailto_url, ":@=&?")
  with open(html_filename, "w") as html:
    with open (os.path.join(tmpldir, "restricted.html.tmpl")) as tmplfile:
      tmpl = tmplfile.read()
    html.write(tmpl.format(**data))
    print "\n\n\n*********\nRESTRICTED: {}\n*********\n\n\n".format(REASON)
    sys.exit(5)

# Command-line args
parser = argparse.ArgumentParser()
parser.add_argument("-p", "--manifest-project", type=str,
                    default="git://github.com/couchbase/manifest",
                    help="Alternate github.com account for manifest")
args = parser.parse_args()
MANIFEST_PROJECT = args.manifest_project

# Clean out report file
html_filename = "restricted.html"
if os.path.exists(html_filename):
  os.remove(html_filename)

# Iterate through restricted manifests
manifests = scan_manifests(MANIFEST_PROJECT)
is_restricted = False
for manifest in manifests:
  meta = manifests[manifest]
  if meta.get("restricted"):
    APPROVAL_TICKET = meta.get("approval_ticket")
    RELEASE_NAME = meta.get("release_name", "Unknown")
    if APPROVAL_TICKET is None:
      print "no approval ticket for restricted manifest {}".format(manifest)
      continue
    if not check_branch_in_manifest(manifest, meta):
      continue
    # Ok, this proposal is to a branch in a restricted manifest - validate it
    is_restricted = True
    print "Project: {} Branch: {} is in restricted manifest: {}".format(
      PROJECT, BRANCH, manifest)
    if not validate_change():
      MANIFEST = manifest
      output_report()

# If we get here, the change is allowed!
# Output "all clear" message if no restricted branches were checked,
# or if they were checked and approved.
if is_restricted:
  print "\n\n\n*********\nAPPROVED: Commit is approved for all restricted manifests\n*********\n\n\n"
else:
  # This is the common case where the change was not to any restricted
  # branches. Normally we want Jenkins to skip voting entirely in this
  # case, to prevent excessive Gerrit comment spam. We indicate this by
  # outputting the word "SILENT". However, if this check was triggered
  # by an explicit "check approval" Gerrit comment, we need to ensure
  # it is not silent in any case.
  silent = " (SILENT)"
  if os.environ.get("GERRIT_EVENT_TYPE") == "comment-added":
    silent = ""
  print "\n\n\n*********\nUNRESTRICTED{}: Branch is in no restricted manifests\n*********\n\n\n".format(silent)

