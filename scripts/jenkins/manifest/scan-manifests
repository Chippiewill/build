#!/usr/bin/env python

import json
import os
import argparse
from subprocess import check_call
from manifest_util import scan_manifests
import time

# Command-line args
parser = argparse.ArgumentParser()
parser.add_argument("-p", "--manifest-project", type=str, default="couchbase",
                    help="Alternate github.com account for manifest")
args = parser.parse_args()
MANIFEST_PROJECT = args.manifest_project

# Initialize results file
result_filename = os.path.abspath("results.json")
if os.path.exists(result_filename):
  os.remove(result_filename)

# Initialize previous-check state file
state_filename = os.path.abspath("last-check.json")
if os.path.exists(state_filename):
  with open(state_filename, "r") as state:
    check_states = json.load(state)
else:
  check_states = {}

# Iterate through the manifests, and find the first one that isn't inactive
# and hasn't been checked in at least 'interval' minutes.
manifests = scan_manifests(MANIFEST_PROJECT)
results = {}
for manifest in manifests:
  # Skip manifests marked "inactive"
  if manifests[manifest].get("inactive", False):
    continue
  # Skip manifests explicitly marked "do-build=False"
  if not manifests[manifest].get("do-build", True):
    continue
  interval = manifests[manifest].get("interval", 240)
  if manifest not in check_states:
    check_states[manifest] = 0L
  now = long(time.time())
  if (now - check_states[manifest] > interval * 60):
    results["MANIFEST"] = manifest
    check_states[manifest] = now
    break

# Save updated check-states
with open(result_filename, "w") as result:
  json.dump(results, result)
with open(state_filename, "w") as state:
  json.dump(check_states, state)


